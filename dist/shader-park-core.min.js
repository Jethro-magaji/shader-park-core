const geometryFunctions={sphere:{args:[1]},line:{args:[3,3,1]},cone:{args:[1,1]},roundCone:{args:[3,3,1,1]},plane:{args:[1,1,1,1]}},mathFunctions={nsin:{args:[1],ret:1},ncos:{args:[1],ret:1},round:{args:[1],ret:1},hsv2rgb:{args:[3],ret:3},rgb2hsv:{args:[3],ret:3},toSpherical:{args:[3],ret:3},fromSpherical:{args:[3],ret:3},getRayDirection:{args:[],ret:3},osc:{args:[1],ret:1},_hash33:{args:[3],ret:1},noise:{args:[3],ret:1},fractalNoise:{args:[3],ret:1},sphericalDistribution:{args:[3,1],ret:4}},glslBuiltInOneToOne=["sin","cos","tan","asin","acos","exp","log","exp2","log2","sqrt","inversesqrt","abs","sign","floor","ceil","fract"],glslBuiltInOther={pow:{args:[1,1],ret:1},mod:{args:[1,1],ret:1},min:{args:[1,1],ret:1},max:{args:[1,1],ret:1},atan:{args:[1,1],ret:1},clamp:{args:[1,1,1],ret:1},step:{args:[1,1],ret:1},smoothstep:{args:[1,1,1],ret:1},length:{args:[3],ret:1},distance:{args:[3,3],ret:1},dot:{args:[3,3],ret:1},cross:{args:[3,3],ret:3},normalize:{args:[3],ret:3},reflect:{args:[3,3],ret:3},refract:{args:[3,3],ret:3}};function convertFunctionToString(e){if("function"==typeof e)return(e=e.toString()).slice(e.indexOf("{")+1,e.lastIndexOf("}"));if("string"!=typeof e)throw"your Shader Park code requires the source code to be a function, or a string";return e}function buildGeoSource(e){return`\nfloat surfaceDistance(vec3 p) {\n\tvec3 normal = vec3(0.0,1.0,0.0);\n\tvec3 mouseIntersect = vec3(0.0,1.0,0.0);\n    float d = 100.0;\n    vec3 op = p;\n${e}\n    return scope_0_d;\n}`}function buildColorSource(e,n){return`\nvec3 shade(vec3 p, vec3 normal) {\n    float d = 100.0;\n    vec3 op = p;\n\tvec3 lightDirection = vec3(0.0, 1.0, 0.0);\n\tvec3 backgroundColor = vec3(1.0, 1.0, 1.0);\n\tvec3 mouseIntersect = vec3(0.0,1.0,0.0);\n\t#ifdef USE_PBR\n\tMaterial material = Material(vec3(1.0),0.5,0.7,1.0);\n\tMaterial selectedMaterial = Material(vec3(1.0),0.5,0.7,1.0);\n\t#else\n\tfloat light = 1.0;\n\tfloat occ = 1.0;\n    vec3 color = vec3(1.0,1.0,1.0);\n\tvec3 selectedColor = vec3(1.0,1.0,1.0);\n\t#endif\n${e}\n${n?"":"    return scope_0_material.albedo;"}\n\t#ifdef USE_PBR\n\treturn pbrLighting(\n\t\tworldPos.xyz,\n\t\tnormal,\n\t\tlightDirection,\n\t\tscope_0_material,\n\t\tbackgroundColor\n\t\t);\n\t#else\n\treturn scope_0_material.albedo*simpleLighting(p, normal, lightDirection, );*occ;\n\t#endif\n}`}function replaceBinaryOp(e){if("object"==typeof e)for(let n in e)e.hasOwnProperty(n)&&replaceBinaryOp(e[n]);if(null!==e&&"BinaryExpression"===e.type){let n=e.operator;"*"!==n&&"/"!==n&&"-"!==n&&"+"!==n||("*"===n?e.callee={type:"Identifier",name:"mult"}:"/"===n?e.callee={type:"Identifier",name:"divide"}:"-"===n?e.callee={type:"Identifier",name:"sub"}:"+"===n&&(e.callee={type:"Identifier",name:"add"}),e.type="CallExpression",e.arguments=[e.left,e.right],e.operator=void 0)}}function replaceOperatorOverload(e){try{if(e&&"object"==typeof e)for(let n in e)e.hasOwnProperty(n)&&replaceOperatorOverload(e[n]);if(e&&"object"==typeof e&&"type"in e&&"ExpressionStatement"===e.type&&"expression"in e&&"AssignmentExpression"===e.expression.type){let n=e.expression.operator;"+="!==n&&"-="!==n&&"/="!==n&&"*="!==n&&"%="!==n||(e.expression.operator="=",e.expression.right={type:"BinaryExpression",left:e.expression.left,right:e.expression.right},"+="===n?e.expression.right.operator="+":"-="===n?e.expression.right.operator="-":"/="===n?e.expression.right.operator="/":"*="===n?e.expression.right.operator="*":"%="===n&&(e.expression.right.operator="%"))}}catch(e){console.error(e)}}function replaceSliderInput(e){try{if(e&&"object"==typeof e)for(let n in e)e.hasOwnProperty(n)&&replaceSliderInput(e[n]);if(e&&"object"==typeof e&&"type"in e&&"VariableDeclaration"===e.type){let n=e.declarations[0],t=n.id.name;n&&n.init&&void 0!==n.init.callee&&("input"===n.init.callee.name||"input2D"===n.init.callee.name)&&n.init.arguments.unshift({type:"Literal",value:t,raw:t})}}catch(e){console.error(e)}}function uniformsToGLSL(e){let n="";for(let t=0;t<e.length;t++){let r=e[t];n+=`uniform ${r.type} ${r.name};\n`}return n}function baseUniforms(){return[{name:"time",type:"float",value:0},{name:"opacity",type:"float",value:1},{name:"_scale",type:"float",value:1},{name:"mouse",type:"vec3",value:[.5,.5,.5]},{name:"stepSize",type:"float",value:.85},{name:"resolution",type:"vec2",value:[800,600]}]}function bindStaticData(e,n){return n=convertFunctionToString(n),`const staticData = JSON.parse(\`${JSON.stringify(e)}\`)\n`+n}function sculptToGLSL(userProvidedSrc){const PI=Math.PI,TWO_PI=2*Math.PI,TAU=TWO_PI;let debug=!1;debug&&console.log("tree",tree);let generatedJSFuncsSource="",geoSrc="",colorSrc="",varCount=0,primCount=0,stateCount=0,useLighting=!0,enable2DFlag=!1,stateStack=[],uniforms=baseUniforms(),stepSizeConstant=.85,maxIterations=300;function box(e,n,t){void 0!==n?(ensureScalar("box",e),ensureScalar("box",n),ensureScalar("box",t),applyMode(`box(${getCurrentState().p}, ${collapseToString(e)}, ${collapseToString(n)}, ${collapseToString(t)})`)):"vec3"===e.type?applyMode(`box(${getCurrentState().p}, ${collapseToString(e)})`):compileError("'box' accepts either an x, y, z, or a vec3")}function torus(e,n){overloadVec2GeomFunc("torus",e,n)}function cylinder(e,n){overloadVec2GeomFunc("cylinder",e,n)}function overloadVec2GeomFunc(e,n,t){void 0!==t?(ensureScalar(e,n),ensureScalar(e,t),applyMode(`${e}(${getCurrentState().p}, ${collapseToString(n)}, ${collapseToString(t)})`)):"vec2"===n.type?applyMode(`${e}(${getCurrentState().p}, ${collapseToString(n)})`):compileError(`'${e}' accepts either an x, y or a vec2`)}let primitivesJS="";for(let[e,n]of Object.entries(geometryFunctions)){let t=n.args;primitivesJS+="function "+e+"(";for(let e=0;e<t.length;e++)0!==e&&(primitivesJS+=", "),primitivesJS+="arg_"+e;primitivesJS+=") {\n";let r=0;for(let n of t)1===n&&(primitivesJS+='    ensureScalar("'+e+'", arg_'+r+");\n"),r+=1;primitivesJS+='    applyMode("'+e+'("+getCurrentState().p+", " + ';for(let e=0;e<t.length;e++)primitivesJS+="collapseToString(arg_"+e+") + ",e<t.length-1&&(primitivesJS+='", " + ');primitivesJS+='")");\n}\n\n'}function generateGLSLWrapper(e){let n="";for(let[t,r]of Object.entries(e)){let e=r.args,o=r.ret;n+="function "+t+"(";for(let t=0;t<e.length;t++)0!==t&&(n+=", "),n+="arg_"+t;n+=") {\n";let a=0;for(let t of e)n+="    arg_"+a+" = tryMakeNum(arg_"+a+");\n",a+=1;n+='    return new makeVarWithDims("'+t+'(" + ';for(let t=0;t<e.length;t++)n+="arg_"+t+" + ",t<e.length-1&&(n+='", " + ');n+='")", '+o+");\n}\n"}return n}function mix(e,n,t){return ensureSameDims("mix",e,n),1!==t.dims&&t.dims!==e.dims&&compileError("'mix' third argument must be float or match dim of first args"),ensureScalar("mix",t),new makeVarWithDims(`mix(${e=tryMakeNum(e)}, ${n=tryMakeNum(n)}, ${t=tryMakeNum(t)})`,e.dims)}function ensureSameDims(e,...n){let t=n.map(e=>e.dim);const r=t[0];for(let n=1;n<t.length;n++){r!==t[n]&&compileError(`'${e}' argument dimensions do not match`)}}generatedJSFuncsSource+=primitivesJS;let mathFunctionsJS=generateGLSLWrapper(mathFunctions);generatedJSFuncsSource+=mathFunctionsJS;let builtInOtherJS=generateGLSLWrapper(glslBuiltInOther);generatedJSFuncsSource+=builtInOtherJS;let builtInOneToOneJS="";for(let e of glslBuiltInOneToOne)builtInOneToOneJS+=`function ${e}(x) {\n    x = tryMakeNum(x);\n\t// debug here\n\treturn new makeVarWithDims("${e}(" + x + ")", x.dims);\n}\n`;function setStepSize(e){"number"!=typeof e&&compileError("setStepSize accepts only a constant number. Was given: '"+e.type+"'"),stepSizeConstant=e}function setGeometryQuality(e){"number"!=typeof e&&compileError("setGeometryQuality accepts only a constant number between 0 and 100. Was given: '"+e.type+"'"),stepSizeConstant=1-.01*e*.995}function setMaxIterations(e){("number"!=typeof e||e<0)&&compileError("setMaxIterations accepts only a constant number >= 0. Was given: '"+e.type+"'"),maxIterations=Math.round(e)}function getCurrentState(){return stateStack[stateStack.length-1]}function getCurrentMode(){return getCurrentState().mode}function getCurrentDist(){return getCurrentState().id+"d"}function getCurrentPos(){return getCurrentState().id+"p"}function getMainMaterial(){return getCurrentState().id+"material"}function getCurrentMaterial(){return getCurrentState().id+"currentMaterial"}function appendSources(e){geoSrc+="    "+e,colorSrc+="    "+e}function appendColorSource(e){colorSrc+="    "+e}function makeVar(e,n,t,r){if(this.type=n,this.dims=t,r)this.name=e;else{let n="v_"+varCount;appendSources(this.type+" "+n+" = "+e+";\n"),varCount+=1,this.name=n}return this.toString=function(){return this.name},this}function float(e,n){return new makeVar(e=collapseToString(e),"float",1,n)}function vec2(e,n,t){void 0===n&&(n=e),"string"!=typeof e&&(e="vec2("+collapseToString(e)+", "+collapseToString(n)+")");let r=new makeVar(e,"vec2",2,t);return applyVectorAssignmentOverload(r,{x:new makeVarWithDims(r.name+".x",1,!0),y:new makeVarWithDims(r.name+".y",1,!0)}),r}function vec3(e,n,t,r){void 0===n&&(n=e,t=e),"string"!=typeof e&&(e="vec3("+collapseToString(e)+", "+collapseToString(n)+", "+collapseToString(t)+")");let o=new makeVar(e,"vec3",3,r);return applyVectorAssignmentOverload(o,{x:new makeVarWithDims(o.name+".x",1,!0),y:new makeVarWithDims(o.name+".y",1,!0),z:new makeVarWithDims(o.name+".z",1,!0)}),o}function vec4(e,n,t,r,o){void 0===n&&void 0===t&&(n=e,t=e,r=e),"string"!=typeof e&&(e="vec4("+collapseToString(e)+", "+collapseToString(n)+", "+collapseToString(t)+", "+collapseToString(r)+")");let a=new makeVar(e,"vec4",4,o);return applyVectorAssignmentOverload(a,{x:new makeVarWithDims(a.name+".x",1,!0),y:new makeVarWithDims(a.name+".y",1,!0),z:new makeVarWithDims(a.name+".z",1,!0),w:new makeVarWithDims(a.name+".w",1,!0)}),a}function applyVectorAssignmentOverload(e,n){Object.entries(n).forEach(([n,t])=>{Object.defineProperty(e,n,{get:()=>t,set:t=>appendSources(`${e.name}.${n} = ${t};\n`)})})}function makeVarWithDims(e,n,t){return(n<1||n>4)&&compileError("Tried creating variable with dim: "+n),1===n?new float(e,t):2===n?new vec2(e,null,t):3===n?new vec3(e,null,null,t):4===n?new vec4(e,null,null,null,t):void 0}generatedJSFuncsSource+=builtInOneToOneJS;const modes={UNION:10,DIFFERENCE:11,INTERSECT:12,BLEND:13,MIXGEO:14},additiveModes=[modes.UNION,modes.BLEND,modes.MIXGEO],materialModes={NORMAL:20,MIXMAT:21};let time=new float("time",!0),mouse=new vec3("mouse",null,null,!0),normal=new vec3("normal",null,null,!0);function mouseIntersection(){return appendColorSource("mouseIntersect = mouseIntersection();\n"),new vec3("mouseIntersect",null,null,!0)}function getRayDirection(){return new vec3("getRayDirection()",null,null,!1)}function compileError(e){throw console.error(e," char: "+geoSrc.length),e}function ensureScalar(e,n){"number"!=typeof n&&"float"!==n.type&&compileError("'"+e+"' accepts only a scalar. Was given: '"+n.type+"'")}function ensureGroupOp(e,n,t){"string"!=typeof n&&"string"!=typeof t&&1!==n.dims&&1!==t.dims&&n.dims!==t.dims&&compileError("'"+e+"' dimension mismatch. Was given: '"+n.type+"' and '"+t.type+"'")}function collapseToString(e){return"string"==typeof e?e:"number"==typeof e?e.toFixed(8):e.toString()}function mixMat(e){getCurrentState().materialMode=materialModes.MIXMAT,ensureScalar("mixMat",e),getCurrentState().matMixAmount=e}function resetMixColor(){getCurrentState().materialMode=materialModes.NORMAL}function union(){getCurrentState().mode=modes.UNION}function difference(){getCurrentState().mode=modes.DIFFERENCE}function intersect(){getCurrentState().mode=modes.INTERSECT}function blend(e){getCurrentState().mode=modes.BLEND,ensureScalar("blend",e),getCurrentState().blendAmount=e}function mixGeo(e){getCurrentState().mode=modes.MIXGEO,ensureScalar("mixGeo",e),getCurrentState().mixAmount=e}function getMode(){switch(getCurrentMode()){case modes.UNION:return["add"];case modes.DIFFERENCE:return["subtract"];case modes.INTERSECT:return["intersect"];case modes.BLEND:return["smoothAdd",getCurrentState().blendAmount];case modes.MIXGEO:return["mix",getCurrentState().mixAmount];default:return["add"]}}function applyMode(e,n){let t="prim_"+primCount;if(primCount+=1,appendSources("float "+t+" = "+e+";\n"),additiveModes.includes(getCurrentMode())){let e=void 0!==n?n:getCurrentMaterial();getCurrentState().materialMode===materialModes.NORMAL?appendColorSource("if ("+t+" < "+getCurrentDist()+") { "+getMainMaterial()+" = "+e+"; }\n"):getCurrentState().materialMode===materialModes.MIXMAT&&appendColorSource(getMainMaterial()+" = blendMaterial("+e+", "+getMainMaterial()+", "+collapseToString(getCurrentState().matMixAmount)+");\n")}let r=getMode();appendSources(getCurrentDist()+" = "+r[0]+"( "+t+", "+getCurrentDist()+" "+(r.length>1?","+collapseToString(r[1]):"")+" );\n")}function getSpace(){return makeVarWithDims(getCurrentState().p.name,3)}function pushState(){stateStack.push({id:"scope_"+stateCount+"_",mode:modes.UNION,materialMode:materialModes.NORMAL,matMixAmount:0,blendAmount:0,mixAmount:0}),appendSources("float "+getCurrentDist()+" = 100.0;\n");let e=stateStack.length>1?stateStack[stateStack.length-2].id+"p":"p",n=stateStack.length>1?stateStack[stateStack.length-2].id+"currentMaterial":"material";appendSources("vec3 "+getCurrentPos()+" = "+e+";\n"),appendColorSource("Material "+getMainMaterial()+" = "+n+";\n"),appendColorSource("Material "+getCurrentMaterial()+" = "+n+";\n"),getCurrentState().p=vec3(getCurrentPos(),null,null,!0),stateCount++}function popState(){let e=getCurrentDist(),n=getMainMaterial();stateStack.pop(),applyMode(e,n)}function shape(e){return function(){pushState();let n=e.apply(this,arguments);return popState(),n}}function tryMakeNum(e){return"number"==typeof e?new float(e):e}function mult(e,n){if("number"==typeof e&&"number"==typeof n)return e*n;e=tryMakeNum(e),n=tryMakeNum(n),debug&&(console.log("multiplying..."),console.log("a: ",e),console.log("b: ",n)),ensureGroupOp("mult",e,n);let t=Math.max(e.dims,n.dims);return new makeVarWithDims("("+collapseToString(e)+"*"+collapseToString(n)+")",t)}function add(e,n){if("number"==typeof e&&"number"==typeof n)return e+n;e=tryMakeNum(e),n=tryMakeNum(n),debug&&(console.log("adding..."),console.log("a: ",e),console.log("b: ",n)),ensureGroupOp("add",e,n);let t=Math.max(e.dims,n.dims);return new makeVarWithDims("("+collapseToString(e)+"+"+collapseToString(n)+")",t)}function sub(e,n){if("number"==typeof e&&"number"==typeof n)return e-n;e=tryMakeNum(e),n=tryMakeNum(n),debug&&(console.log("subtracting..."),console.log("a: ",e),console.log("b: ",n)),ensureGroupOp("sub",e,n);let t=Math.max(e.dims,n.dims);return new makeVarWithDims("("+collapseToString(e)+"-"+collapseToString(n)+")",t)}function divide(e,n){if("number"==typeof e&&"number"==typeof n)return e/n;e=tryMakeNum(e),n=tryMakeNum(n),debug&&(console.log("dividing..."),console.log("a: ",e),console.log("b: ",n)),ensureGroupOp("divide",e,n);let t=Math.max(e.dims,n.dims);return new makeVarWithDims("("+collapseToString(e)+"/"+collapseToString(n)+")",t)}function setSDF(e){ensureScalar("setSDF",e),applyMode(collapseToString(e))}function getSDF(){return float(getCurrentDist(),!0)}function reset(){stateStack.length>1?appendSources(getCurrentPos()+" = "+stateStack[stateStack.length-2].id+"p;\n"):appendSources(getCurrentPos()+" = op;\n")}function displace(e,n,t){void 0===n||void 0===t?appendSources(getCurrentPos()+" -= "+collapseToString(e)+";\n"):(ensureScalar("displace",e),ensureScalar("displace",n),ensureScalar("displace",t),appendSources(getCurrentPos()+" -= vec3( "+collapseToString(e)+", "+collapseToString(n)+", "+collapseToString(t)+");\n"))}function setSpace(e,n,t){void 0===n||void 0===t?appendSources(getCurrentPos()+" = "+collapseToString(e)+";\n"):(ensureScalar("setSpace",e),ensureScalar("setSpace",n),ensureScalar("setSpace",t),appendSources(getCurrentPos()+" = vec3( "+collapseToString(e)+", "+collapseToString(n)+", "+collapseToString(t)+");\n"))}function repeat(e,n){let t=collapseToString(e),r=collapseToString(n);appendSources(getCurrentPos()+" = "+getCurrentPos()+"-"+t+"*clamp(round("+getCurrentPos()+"/"+t+"),-"+r+" ,"+r+");\n")}function rotateX(e){ensureScalar("rotateX",e),appendSources(getCurrentPos()+".yz = "+getCurrentPos()+".yz*rot2("+collapseToString(e)+");\n")}function rotateY(e){ensureScalar("rotateY",e),appendSources(getCurrentPos()+".xz = "+getCurrentPos()+".xz*rot2("+collapseToString(e)+");\n")}function rotateZ(e){ensureScalar("rotateZ",e),appendSources(getCurrentPos()+".xy = "+getCurrentPos()+".xy*rot2("+collapseToString(e)+");\n")}function mirrorX(){appendSources(getCurrentPos()+".x = abs("+getCurrentPos()+".x);\n")}function mirrorY(){appendSources(getCurrentPos()+".y = abs("+getCurrentPos()+".y);\n")}function mirrorZ(){appendSources(getCurrentPos()+".z = abs("+getCurrentPos()+".z);\n")}function mirrorXYZ(){appendSources(getCurrentPos()+" = abs("+getCurrentPos()+");\n")}function flipX(){appendSources(getCurrentPos()+".x = -"+getCurrentPos()+".x;\n")}function flipY(){appendSources(getCurrentPos()+".y = -"+getCurrentPos()+".y;\n")}function flipZ(){appendSources(getCurrentPos()+".z = -"+getCurrentPos()+".z;\n")}function expand(e){ensureScalar("expand",e),appendSources(getCurrentDist()+" -= "+collapseToString(e)+";\n")}function shell(e){ensureScalar("shell",e),appendSources(getCurrentDist()+" = shell( "+getCurrentDist()+","+collapseToString(e)+");\n")}function color(e,n,t){void 0!==n?(ensureScalar("color",e),ensureScalar("color",n),ensureScalar("color",t),appendColorSource(getCurrentMaterial()+".albedo = vec3("+collapseToString(e)+", "+collapseToString(n)+", "+collapseToString(t)+");\n")):("vec3"!==e.type&&compileError("albedo must be vec3"),appendColorSource(getCurrentMaterial()+".albedo = "+collapseToString(e)+";\n"))}function metal(e){ensureScalar("metal",e),appendColorSource(getCurrentMaterial()+".metallic = "+collapseToString(e)+";\n")}function shine(e){ensureScalar("shine",e),appendColorSource(getCurrentMaterial()+".roughness = 1.0-"+collapseToString(e)+";\n")}function lightDirection(e,n,t){void 0===n||void 0===t?appendColorSource("lightDirection = "+collapseToString(e)+";\n"):(ensureScalar("lightDirection",e),ensureScalar("lightDirection",n),ensureScalar("lightDirection",t),appendColorSource("lightDirection = vec3( "+collapseToString(e)+", "+collapseToString(n)+", "+collapseToString(t)+");\n"))}function backgroundColor(e,n,t){void 0===n||void 0===t?appendColorSource("backgroundColor = "+collapseToString(e)+";\n"):(ensureScalar("backgroundColor",e),ensureScalar("backgroundColor",n),ensureScalar("backgroundColor",t),appendColorSource("backgroundColor = vec3( "+collapseToString(e)+", "+collapseToString(n)+", "+collapseToString(t)+");\n"))}function noLighting(){useLighting=!1}function basicLighting(){}function occlusion(e){let n="1.0";void 0!==e&&(ensureScalar("occlusion",e),n=collapseToString(e)),appendColorSource(getCurrentMaterial()+".ao = mix(1.0, occlusion(op,normal), "+n+");\n")}function test(){appendSources("//this is a test\n")}function input(e,n=0,t=0,r=1){return"number"==typeof n&&"number"==typeof t&&"number"==typeof r||compileError("input value, min, and max must be constant numbers"),uniforms.push({name:e,type:"float",value:n,min:t,max:r}),new float(e,!0)}function input2D(e,n={x:0,y:0},t={x:0,y:0},r={x:1,y:1}){if("number"==typeof n&&"number"==typeof t&&"object"==typeof r){let r=n,o=t;return uniforms.push({name:e,type:"vec2",value:{x:r,y:o},min:{x:0,y:0},max:{x:1,y:1}}),new vec2(e,!0)}return"object"==typeof n&&"object"==typeof t&&"object"==typeof r||compileError("input2D: value, min, and max must be a vec2"),[n,t,r].reduce((e,n)=>e&&"x"in n&&"y"in n)||compileError("input2D: value, min, and max must be a vec2"),uniforms.push({name:e,type:"vec2",value:n,min:t,max:r}),new vec2(e,!0)}function getPixelCoord(){return makeVarWithDims("gl_FragCoord.xy",2,!0)}function getResolution(){return makeVarWithDims("resolution",2,!0)}function get2DCoords(){return makeVarWithDims("vec2((gl_FragCoord.x/resolution.x-0.5)*(resolution.x/resolution.y),gl_FragCoord.y/resolution.y-0.5)",2,!1)}function enable2D(){return setMaxIterations(0),noLighting(),enable2DFlag=!0,get2DCoords()}pushState();let error=void 0;function getSpherical(){return toSpherical(getSpace())}let postGeneratedFunctions=[getSpherical].map(e=>e.toString()).join("\n");eval(generatedJSFuncsSource+postGeneratedFunctions+userProvidedSrc),enable2DFlag&&setSDF(0);let geoFinal=buildGeoSource(geoSrc),colorFinal=buildColorSource(colorSrc,useLighting);return{uniforms:uniforms,stepSizeConstant:stepSizeConstant,maxIterations:maxIterations,geoGLSL:geoFinal,colorGLSL:colorFinal,error:error}}const defaultFragSourceGLSL="float surfaceDistance(vec3 p) {\n    float d = sphere(p, 0.3);\n\treturn d;\n}\n\nvec3 shade(vec3 p, vec3 normal) {\n    vec3 lightDirection = vec3(0.0, 1.0, 0.0);\n    float light = simpleLighting(p, normal, lightDirection);\n    vec3 color = vec3(1.0, 1.0, 1.0);\n\treturn color*light;\n}\n",threeJSVertexSource="\nvarying vec4 worldPos;\n//varying vec2 vUv;\nvarying vec3 sculptureCenter;\nvoid main()\n{\n    vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n    worldPos = modelMatrix*vec4(position,1.0);\n    sculptureCenter = (modelMatrix * vec4(0., 0., 0., 1.)).xyz;\n    //vUv = uv;\n    gl_Position = projectionMatrix * mvPosition;\n}\n",minimalVertexSource="\nattribute vec3 coordinates;\nvarying vec3 sculptureCenter;\nvoid main(void) {\n     sculptureCenter = vec3(0.0);\n     gl_Position = vec4(coordinates, 1.0);\n}",threeHeader="\n#define GLSL_NEED_ROUND\nuniform mat4 projectionMatrix;\nuniform sampler2D msdf;\n\n//varying vec2 vUv;\nvarying vec4 worldPos;\nvarying vec3 sculptureCenter;\n",minimalHeader="\nprecision highp float;\n#define GLSL_NEED_ROUND\nuniform mat4 projectionMatrix;\nvarying vec3 sculptureCenter;\n#define cameraPosition vec3(0.0,0.0,-2.0)\n#define vUv vec2(0.0)\n#define worldPos vec4(vec2((gl_FragCoord.x/resolution.x-0.5)*(resolution.x/resolution.y),gl_FragCoord.y/resolution.y-0.5)*1.75,0.0,0.0)\n",usePBRHeader="#define USE_PBR\n",useHemisphereLight="#define HEMISPHERE_LIGHT\n",sculptureStarterCode="\nfloat surfaceDistance(vec3 p);\n\nconst float PI = 3.14159265;\nconst float TAU = PI*2.0;\nconst float TWO_PI = TAU;\n\nconst float max_dist = 100.0;\nconst float intersection_threshold = 0.00001;\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    float ao;\n};\n\nMaterial blendMaterial(Material a, Material b, float amount) {\n    return Material(\n        mix(a.albedo, b.albedo, amount), \n        mix(a.metallic, b.metallic, amount), \n        mix(a.roughness, b.roughness, amount), \n        mix(a.ao, b.ao, amount)\n    );\n}\n\n// Trig functions normalized to the range 0.0-1.0\nfloat nsin(float x) {\n    return sin(x)*0.5+0.5;\n}\n\nfloat ncos(float x) {\n    return cos(x)*0.5+0.5;\n}\n\n#ifdef GLSL_NEED_ROUND\nfloat round(float x) {\n    return floor(x+0.5);\n}\nvec2 round(vec2 x) {\n    return floor(x+0.5);\n}\nvec3 round(vec3 x) {\n    return floor(x+0.5);\n}\nvec4 round(vec4 x) {\n    return floor(x+0.5);\n}\n#endif\n\nfloat softSquare(float x, int pw) {\n    return 1.0/(pow(tan(x),float(pw+1)*2.0)+1.0);\n}\n\n// Simple oscillators \n\nfloat osc(float freq, float amp, float base, float phase) {\n    return base+amp*sin(TWO_PI*(freq*time+phase));\n}\n\nfloat osc(float freq, float amp, float base) {\n    return osc(freq, amp, base, 0.0);\n}\n\nfloat osc(float freq, float amp) {\n    return osc(freq, amp, 1.0);\n}\n\nfloat osc(float freq) {\n    return osc(freq, 0.5);\n}\n\nfloat osc() {\n    return osc(1.0);\n}\n\n// Color Conversion\n// https://www.shadertoy.com/view/lsS3Wc\nvec3 hsv2rgb( vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( vec3 c)\n{\n    const float eps = 0.0000001;\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\n\n// Primitives\n\nfloat line(vec3 p, vec3 a, vec3 b) {\n\tvec3 pa = p-a;\n  \tvec3 ba = b-a;\n\tfloat t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  \treturn length(pa - ba*t);\n}\n\n//line with radius\nfloat line( vec3 p, vec3 a, vec3 b, float radius ){\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - radius;\n}\n\nfloat sphere( vec3 p, float size ){\n  return length(p)-size;\n}\n\nfloat uBox( vec3 p, vec3 b ){\n  return length(max(abs(p)-b,0.0));\n}\n\nfloat uRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat box( vec3 p, vec3 box ){\n  vec3 d = abs(p) - box;\n  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat box( vec3 p, float bx, float by, float bz) {\n    vec3 box = vec3(bx,by,bz);\n    vec3 d = abs(p) - box;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat roundedBox( vec3 p, vec3 box , float r){\n  return length(max(abs(p)-box,0.0))-r;\n}\n\nfloat torus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat torus( vec3 p, float tx, float ty ){\n    vec2 q = vec2(length(p.xz)-tx,p.y);\n    return length(q)-ty;\n}\n\nfloat infCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\nfloat cylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat cylinder( vec3 p, float hx, float hy)\n{\n    return cylinder(p, vec2(hx,hy));\n}\n\nfloat cone( vec3 p, vec2 c )\n{\n    // c must be normalized\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat plane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat plane( vec3 p, float nx, float ny, float nz, float nw)\n{\n  // n must be normalized\n  return dot(p,normalize(vec3(nx,ny,nz))) + nw;\n}\n\nfloat hexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025+q.y*0.5),q.y)-h.x);\n}\n\nfloat triPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat triangularPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat cappedCone( vec3 p, vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n    vec2 w = v - q;\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n    vec2 d = max(qv,0.0)*qv/vv;\n    return sqrt( dot(w,w) - max(d.x,d.y) ) * sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat roundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    vec3 rv = pa*l2 - ba*y;\n    float x2 = dot(rv,rv);\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat ellipsoid( vec3 p, vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nvec3 toSpherical(vec3 p) {\n    float phi = atan(p.x,p.z);\n    float r = length(p);\n    float theta = acos(-p.y/r);\n    return vec3(r,theta,phi);\n}\n\nvec3 fromSpherical(vec3 p) {\n    return vec3(p.x*sin(p.y)*cos(p.z), p.x*sin(p.y)*sin(p.z), p.x*cos(p.y));\n}\n\nfloat dot2( vec3 v ) { return dot(v,v); }\n\nfloat uTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n    vec3 ba = b - a; vec3 pa = p - a;\n    vec3 cb = c - b; vec3 pb = p - b;\n    vec3 ac = a - c; vec3 pc = p - c;\n    vec3 nor = cross( ba, ac );\n    return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat add( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat add(float d1, float d2, float d3) {\n   return min(d1, min(d2,d3));\n}\n\nfloat add(float d1, float d2, float d3, float d4) {\n    return min(min(d1,d2),min(d3,d4));\n}\n\nfloat add(float d1, float d2, float d3, float d4, float d5) {\n    return min(min(min(d1,d2), min(d3,d4)),d5);\n}\n\nfloat add(float d1, float d2, float d3, float d4, float d5, float d6) {\n    return min(min(min(d1,d2),min(d3,d4)),min(d5,d6));\n}\n\nfloat add(float d1, float d2, float d3, float d4, float d5, float d6, float d7) {\n    return min(min(min(d1,d2),min(d3,d4)),min(min(d5,d6),d7));\n}\n\nfloat subtract( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat intersect( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat shell(float d, float thickness) {\n    return abs(d)-thickness;\n}\n\nvec3 repeat3D(vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nfloat repeat1D(float p, float size)\n{\n\tfloat halfSize = size * 0.5;\n\tfloat c = floor((p + halfSize) / size);\n  \tp = mod(p + halfSize, size)-halfSize;\n  \treturn c;\n}\n\nmat2 rot2(float a){\n    float c = cos(a); float s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\n// polynomial smooth min (k = 0.1) (from IQ)\nfloat smoothAdd( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat smoothSubtract(float a,float b, float k)\n{\n    return -smoothAdd(-a,-b,k);\n}\n\nvec2 _hash( vec2 p ) // replace this by something better\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = step(a.yx,a.xy);    \n    vec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3 n = h*h*h*h*vec3( dot(a,_hash(i+0.0)), dot(b,_hash(i+o)), dot(c,_hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nvec3 _hash33(vec3 p3)\n{\n    p3 = fract(p3 * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n// simplex noise from https://www.shadertoy.com/view/4sc3z2\nfloat noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n    \n    // thx nikita: https://www.shadertoy.com/view/XsX3zB\n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, _hash33(i)), dot(d1, _hash33(i + i1)), dot(d2, _hash33(i + i2)), dot(d3, _hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n\nfloat fractalNoise(vec3 p, float falloff, int iterations) {\n    float v = 0.0;\n    float amp = 1.0;\n    float invFalloff = 1.0/falloff;\n    for (int i=0; i<10; i++) {\n        v += noise(p)*amp;\n\tif (i>=iterations) break;\n        amp *= invFalloff;\n        p *= falloff;\n    }\n    return v;\n} \n\nfloat fractalNoise(vec3 p) {\n    return fractalNoise(p, 2.0, 5);\n}\n\n// Adapted from IQ's usage at https://www.shadertoy.com/view/lllXz4\n// Spherical Fibonnacci points, Benjamin Keinert, Matthias Innmann,\n// Michael Sanger and Marc Stamminger\n\nconst float PHI = 1.61803398875;\n\nvec4 sphericalDistribution( vec3 p, float n )\n{\n    p = normalize(p);\n    float m = 1.0 - 1.0/n;\n\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n\n    float k = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI+1.0)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    vec2 F = vec2( round(Fk), round(Fk * PHI) ); // k, k+1\n\n    vec2 ka = 2.0*F/n;\n    vec2 kb = 2.0*PI*( fract((F+1.0)*PHI) - (PHI-1.0) );\n\n    mat2 iB = mat2( ka.y, -ka.x,\n    kb.y, -kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - m));\n    float d = 8.0;\n    float j = 0.0;\n    vec3 bestQ = vec3(0.0,0.0,8.0);\n    for( int s=0; s<4; s++ )\n    {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n\n        float i = dot(F, uv + c); // all quantities are ingeters (can take a round() for extra safety)\n\n        float phi = 2.0*PI*fract(i*PHI);\n        float cosTheta = m - 2.0*i/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta );\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d)\n        {\n            d = squaredDistance;\n            j = i;\n            bestQ = q;\n        }\n    }\n    return vec4(bestQ,sqrt(d));\n}\n\n// Compute intersection of ray and SDF. You probably won't need to modify this.\nfloat intersect(vec3 ro, vec3 rd, float stepFraction) {\n    float t = 0.0;\n\tfor(int i = 0; i < MAX_ITERATIONS; ++i) {\n\t\tfloat h = surfaceDistance((ro+rd*t));\n\t\tif(h < intersection_threshold || t > max_dist) break;\n\t\tt += h*STEP_SIZE_CONSTANT;\n    }\n\treturn t;\n}\n\nvec3 getRayDirection() {\n\treturn normalize(worldPos.xyz-cameraPosition);\n}\n\nvec3 mouseIntersection() {\n    vec3 rayDirection = getRayDirection();\n    return mouse+rayDirection*intersect(mouse, rayDirection, 0.8);\n}\n\n// Calculate the normal of a SDF\nvec3 calcNormal( vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.0005;\n    return normalize( e.xyy*surfaceDistance( pos + e.xyy ) + \n\t\t      e.yyx*surfaceDistance( pos + e.yyx ) + \n\t\t      e.yxy*surfaceDistance( pos + e.yxy ) + \n\t\t      e.xxx*surfaceDistance( pos + e.xxx ) );\n}\n\n// from https://learnopengl.com/PBR/Lighting\nvec3 fresnelSchlick(float cosTheta, vec3 F0)\n{\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}  \n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness)\n{\n    float a      = roughness*roughness;\n    float a2     = a*a;\n    float NdotH  = max(dot(N, H), 0.0);\n    float NdotH2 = NdotH*NdotH;\n\t\n    float num   = a2;\n    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n    denom = PI * denom * denom;\n\t\n    return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness)\n{\n    float r = (roughness + 1.0);\n    float k = (r*r) / 8.0;\n\n    float num   = NdotV;\n    float denom = NdotV * (1.0 - k) + k;\n\t\n    return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n{\n    float NdotV = max(dot(N, V), 0.0);\n    float NdotL = max(dot(N, L), 0.0);\n    float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n    float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n\t\n    return ggx1 * ggx2;\n}\n\n// adapted from https://learnopengl.com/PBR/Lighting\nvec3 pbrLighting(vec3 WordPos, vec3 N, vec3 lightdir, Material mat, vec3 backgroundColor) {\n\n    vec3 V = -getRayDirection();\n    vec3 F0 = vec3(0.04); \n    F0 = mix(F0, mat.albedo, mat.metallic);\n\t\n    // reflectance equation\n    vec3 Lo = vec3(0.0);\n\n    // calculate per-light radiance\n    vec3 L = normalize(lightdir);\n    vec3 H = normalize(V + L);        \n    \n    // cook-torrance brdf\n    float NDF = DistributionGGX(N, H, mat.roughness);        \n    float G   = GeometrySmith(N, V, L, mat.roughness);      \n    vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);    \n\n    vec3 kS = F;\n    vec3 kD = vec3(1.0) - kS;\n    kD *= 1.0 - mat.metallic;\t  \n    \n    vec3 numerator    = NDF * G * F;\n    float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n    vec3 specular     = numerator / max(denominator, 0.001);  \n    \n    // add to outgoing radiance Lo\n    float NdotL = max(dot(N, L), 0.0);                \n    Lo += (kD * mat.albedo / PI + specular) * NdotL;  \n  \n    float hemi = 1.0;\n    #ifdef HEMISPHERE_LIGHT\n    // ground is black, taken into account by ambient light\n    hemi = NdotL*1.25;\n    #endif\n\n    vec3 ambient = (vec3(1.2+hemi) * mat.albedo) * mat.ao;\n    vec3 color = ambient + Lo*1.7;\n    \n    /// this section adds edge glow as if there were a white env map ///\n    /// there should probably be a way to disable it //\n    float lt = 1.0-max(dot(N,V),0.0);\n    lt = pow(lt,6.0);\n    color += 16.0*lt*(0.2+mat.albedo)*mat.metallic*backgroundColor*(1.3-mat.roughness);\n    ///\n    \n    color = color / (color + vec3(1.0));\n    color = pow(color, vec3(1.0/2.2));\n   \n    return color;\n}\n\nfloat simpleLighting(vec3 p, vec3 normal, vec3 lightdir) {\n    // Simple phong-like shading\n    float value = clamp(dot(normal, normalize(lightdir)),0.0, 1.0);\n    return value * 0.3 + 0.7;\n}\n\nfloat specularLighting(vec3 p, vec3 normal, vec3 lightDirection, float shine) {\n    float lamb = clamp(dot(normal,normalize(lightDirection)),0.0,1.0);\n    float spec = pow(lamb, exp(10.0*shine));\n    lamb = 0.4*lamb + 0.4 + 0.2*spec;\n    return lamb;\n}\n\nfloat shadow(vec3 p, vec3 lightDirection, float amount) {\n    float t = intersect(p+0.001*lightDirection, lightDirection, stepSize);\n    return t < (max_dist - 0.1) ? 1.0-amount : 1.0;\n}\n\n// From https://www.shadertoy.com/view/XslSWl\nfloat occlusion(vec3 p,vec3 n) { \n    const int AO_SAMPLES = 8;\n    const float INV_AO_SAMPLES = 1.0/float(AO_SAMPLES);\n    const float R = 0.9;\n    const float D = 0.8;\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.05+f*R;\n        float d = surfaceDistance(p + n * h) - 0.003;\n        r += clamp(h*D-d,0.0,1.0) * (1.0-f);\n    }    \n    return clamp(1.0-r,0.0,1.0);\n}\n",fragFooter="\n// For advanced users //\nvoid main() {\n\n    vec3 rayOrigin = (cameraPosition - sculptureCenter) / max(intersection_threshold, _scale);\n    vec3 rayDirection = getRayDirection();\n    float t = intersect(rayOrigin, rayDirection, stepSize);\n    if(t < max_dist) {\n        vec3 p = (rayOrigin + rayDirection*t);\n        //vec4 sp = projectionMatrix*viewMatrix*vec4(p,1.0); //could be used to set FragDepth\n        vec3 normal = calcNormal(p);\n        // p *= _scale;\n        vec3 col = shade(p, normal);\n        gl_FragColor = vec4(col, opacity);\n        \n    } else {\n        discard;\n    }\n}\n";function glslToThreeJSShaderSource(e){return{uniforms:baseUniforms(),frag:threeHeader+"const float STEP_SIZE_CONSTANT = 0.9;\nconst int MAX_ITERATIONS = 300;\n"+uniformsToGLSL(baseUniforms())+sculptureStarterCode+e+fragFooter,vert:threeJSVertexSource}}function glslToThreeJSMaterial(e,n){let t=glslToThreeJSShaderSource(e);return makeMaterial(t.uniforms,t.vert,t.frag,n)}function glslToThreeJSMesh(e,n){return makeBasicMesh(glslToThreeJSMaterial(e,n))}function sculptToThreeJSShaderSource(e){const n=sculptToGLSL(e);n.error&&console.log(n.error);let t=threeHeader+usePBRHeader+useHemisphereLight+uniformsToGLSL(n.uniforms)+"const float STEP_SIZE_CONSTANT = "+n.stepSizeConstant+";\nconst int MAX_ITERATIONS = "+n.maxIterations+";\n"+sculptureStarterCode+n.geoGLSL+"\n"+n.colorGLSL+"\n"+fragFooter;return{uniforms:n.uniforms,frag:t,vert:threeJSVertexSource,error:n.error,geoGLSL:n.geoGLSL,colorGLSL:n.colorGLSL}}function sculptToThreeJSMaterial(e,n){let t=sculptToThreeJSShaderSource(e),r=makeMaterial(t.uniforms,t.vert,t.frag,n);return r.uniformDescriptions=t.uniforms,r}function sculptToThreeJSMesh(e,n){return makeBasicMesh(sculptToThreeJSMaterial(e=convertFunctionToString(e),n))}function createSculptureWithGeometry(e,n,t=(()=>({})),r={}){e.computeBoundingSphere();let o="radius"in r?r.radius:e.boundingSphere.radius;return r.radius=o,r.geometry=e,createSculpture(n,t,r)}function createSculpture(e,n=(()=>({})),t={}){e=convertFunctionToString(e);let r,o="radius"in t?t.radius:2;if("geometry"in t)r=t.geometry;else{let e="segments"in t?t.segments:8;r=new THREE.SphereBufferGeometry(o,e,e)}let a=sculptToThreeJSMaterial(e);a.uniforms.opacity.value=1,a.uniforms.mouse.value=new THREE.Vector3,a.uniforms._scale.value=o;let i=new THREE.Mesh(r,a);return i.onBeforeRender=function(e,t,r,o,a,i){let l=n();if("object"!=typeof l)throw"createSculpture takes, (source, uniformCallback, params) the uniformCallback must be a function that returns a dictionary of uniforms to update";for(const[e,n]of Object.entries(l))a.uniforms[e].value=n},i}function uniformDescriptionToThreeJSFormat(e,n){let t={};return e.forEach(e=>{"float"===e.type?t[e.name]={value:e.value}:"vec2"===e.type?t[e.name]={value:new THREE.Vector2(e.value.x,e.value.y)}:"vec3"===e.type?t[e.name]={value:new THREE.Vector3(e.value.x,e.value.y,e.value.z)}:"vec4"===e.type&&(t[e.name]={value:new THREE.Vector4(e.value.x,e.value.y,e.value.z,e.value.w)})}),t}function makeMaterial(e,n,t,r){const o=new THREE.ShaderMaterial({uniforms:uniformDescriptionToThreeJSFormat(e,r),vertexShader:n,fragmentShader:t,transparent:!0,side:THREE.BackSide});return o.extensions.fragDepth=!1,o}function makeBasicMesh(e){return new Mesh(new THREE.BoxBufferGeometry(2,2,2),e)}console.log("using shader-park version: 0.1.4");export{createSculpture,createSculptureWithGeometry};